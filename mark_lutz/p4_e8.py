"""
Снова простые числа. Вспомните показанный ниже фрагмент кода из главы 13, который упрощенно определял,
является ли положительное целое число простым:
х = у // 2 # Для значений у > 1
while х > 1:
    if у % х == 0: # Остаток от деления
        print (у, 'has factor', х) # Имеет сомножитель
        break # Пропуск else
    х -= 1
else: # Нормальный выход
    print (у, 'is prime') # Является простым
Упакуйте данный код как многократно используемую функцию в файле модуля (имя у должно быть передаваемым аргументом)
и добавьте в конец файла несколько вызовов функции. Пока вы делаете это, поэкспериментируйте с заменой операции //
в первой строке операцией /, чтобы посмотреть, как настоящее деление изменяет поведение операции / в Python З.Х
и нарушает работу кода (обратитесь в главу 5, если требуется напоминание). Что можно сделать с отрицательными числами
и значениями 0 и 1? Как насчет ускорения работы функции?
"""


def primeNumbers(y):
    if y <= 1:
        print(f'{y} - не натуральное число или единица')
        return
    x = y // 2
    while x > 1:
        if y % x == 0:
            print(f'Число {y} имеет сомножитель {x}')
            break
        x -= 1
    else:
        print(f'{y} простое число')


if __name__ == '__main__':
    primeNumbers(1)
    primeNumbers(-5)
    primeNumbers(13)
    primeNumbers(13.0)
    primeNumbers(15)
    primeNumbers(15.0)
